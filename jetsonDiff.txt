diff --git a/onboard/cv/main.cpp b/onboard/cv/main.cpp
index daa3c5c..a832b70 100644
--- a/onboard/cv/main.cpp
+++ b/onboard/cv/main.cpp
@@ -4,20 +4,13 @@
 using namespace cv;
 using namespace std;
 
-
-
-float minDepth = 1; //need to set
-float pixelWidth = 1; //need to set
-float pixelHeight = 1;
-int roverPixWidth = 1; //initialize
-
 int calcFocalWidth(){   //mm
     return tan(fieldofView/2) * focalLength;
 }
 
-int calcRoverPix(float dist){   //pix
+int calcRoverPix(float dist, float pixWidth){   //pix
     float roverWidthSensor = realWidth * 1.2  * focalLength/(dist * 1000);
-    return roverWidthSensor*(pixelWidth/2)/calcFocalWidth();
+    return roverWidthSensor*(pixWidth/2)/calcFocalWidth();
 }
 
 float getGroundDist(float angleOffset){  // the expected distance if no obstacles
@@ -38,7 +31,7 @@ bool cam_grab_succeed(Camera &cam, int & counter_fail) {
     cerr << "grab failed once\n";
     counter_fail++;
     usleep(1000);
-    if (counter_fail > 1000000) {
+    if (counter_fail > 1000) {
       cerr<<"camera failed\n";
       return false;
     }
@@ -76,96 +69,106 @@ void write_curr_frame_to_disk(Mat &rgb, Mat & depth, int counter ) {
 }
 
 int main() {
-    /*initialize camera*/
-    Camera cam;
-    int j = 0;
-    double frame_time = 0;
-    int counter_fail = 0;
-    #ifdef PERCEPTION_DEBUG
+
+  /*initialize camera*/
+  Camera cam;
+  int j = 0;
+  double frame_time = 0;
+  int counter_fail = 0;
+  #ifdef PERCEPTION_DEBUG
     namedWindow("image",1);
     namedWindow("depth",2);
+  #endif
+  disk_record_init();
+
+  /*initialize lcm messages*/
+  lcm::LCM lcm_;
+  rover_msgs::TennisBall tennisMessage;
+  rover_msgs::Obstacle obstacleMessage;
+  tennisMessage.found = false;
+  obstacleMessage.detected = false;
+
+  int tennisBuffer = 0;
+
+  
+  while (true) {
+    if (!cam_grab_succeed(cam, counter_fail)) break;
+  
+    auto start = chrono::high_resolution_clock::now();
+    Mat src = cam.image();
+    
+    #ifdef PERCEPTION_DEBUG
+          imshow("image", src);
     #endif
-    disk_record_init();
-   
-    while (true) {
-        if (!cam_grab_succeed(cam, counter_fail)) break;
-      
-        auto start = chrono::high_resolution_clock::now();
-        Mat src = cam.image();
-	#ifdef PERCEPTION_DEBUG
-        imshow("image", src);
-	#endif
-        Mat depth_img = cam.depth();
-
-	// write to disk if permitted
-	write_curr_frame_to_disk(src, depth_img, j );
-
-        /*initialize lcm messages*/
-        lcm::LCM lcm_;
-        rover_msgs::TennisBall tennisMessage;
-        rover_msgs::Obstacle obstacleMessage;
-        tennisMessage.found = false;
-        obstacleMessage.detected = false;
-
-        /*initialize obstacle detection*/
-        pixelWidth = src.cols;
-        pixelHeight = src.rows;
-        roverPixWidth = calcRoverPix(distThreshold);
-        float expectedDist = getGroundDist(angleOffset);
-        minDepth = getObstacleMin(expectedDist);
-
-	/* obstacle detection */
-        obstacle_return obstacle_detection =  avoid_obstacle_sliding_window(depth_img, src,  num_sliding_windows , roverPixWidth);
-        if(obstacle_detection.bearing > 0.05 || obstacle_detection.bearing < -0.05) {
-	  cout<< "bearning not zero!\n";
-	  obstacleMessage.detected = true;    //if an obstacle is detected in front
-	} else {
-	  cout<<"bearing zero\n";
-	  obstacleMessage.detected = false;
-	}
-        obstacleMessage.bearing = obstacle_detection.bearing;
-
-	#ifdef PERCEPTION_DEBUG
-	cout << "Turn " << obstacleMessage.bearing << ", detected " << (bool)obstacleMessage.detected<< endl;
-	#endif
-
-	/* Tennis ball detection*/
-        vector<Point2f> centers = findTennisBall(src, depth_img);
-        if(centers.size() != 0){
-	    float dist = depth_img.at<float>(centers[0].y, centers[0].x);
-	    if (dist < BALL_DETECTION_MAX_DIST) {
-	      tennisMessage.distance = dist;
-	      tennisMessage.bearing = getAngle((int)centers[0].x, src.cols);
-
-	      tennisMessage.found = true;
-	      #ifdef PERCEPTION_DEBUG
-	      cout << centers.size() << " tennis ball(s) detected: " << tennisMessage.distance 
+          Mat depth_img = cam.depth();
+
+    // write to disk if permitted
+    write_curr_frame_to_disk(src, depth_img, j );
+
+    /*initialize obstacle detection*/
+    float pixelWidth = src.cols;
+    //float pixelHeight = src.rows;
+    int roverPixWidth = calcRoverPix(distThreshold, pixelWidth);
+
+    /* obstacle detection */
+    obstacle_return obstacle_detection =  avoid_obstacle_sliding_window(depth_img, src,  num_sliding_windows , roverPixWidth);
+    if(obstacle_detection.bearing > 0.05 || obstacle_detection.bearing < -0.05) {
+      cout<< "bearing not zero!\n";
+      obstacleMessage.detected = true;    //if an obstacle is detected in front
+    } else {
+      cout<<"bearing zero\n";
+      obstacleMessage.detected = false;
+    }
+    obstacleMessage.bearing = obstacle_detection.bearing;
+
+    #ifdef PERCEPTION_DEBUG
+    cout << "Turn " << obstacleMessage.bearing << ", detected " << (bool)obstacleMessage.detected<< endl;
+    #endif
+
+    /* Tennis ball detection*/
+    vector<Point2f> centers = findTennisBall(src, depth_img);
+    patchNaNs(depth_img, 6.0);
+    if(centers.size() != 0){
+      float dist = depth_img.at<float>(centers[0].y, centers[0].x);
+      if(dist < .5) dist = 0;
+      if (dist < BALL_DETECTION_MAX_DIST) {
+        tennisMessage.distance = dist;
+        tennisMessage.bearing = getAngle((int)centers[0].x, src.cols);
+
+        tennisMessage.found = true;
+        tennisBuffer = 0;
+
+        #ifdef PERCEPTION_DEBUG
+        cout << centers.size() << " tennis ball(s) detected: " << tennisMessage.distance 
                                                         << "m, " << tennisMessage.bearing << "degrees\n";
-	      #endif
-	    } else
-	      tennisMessage.found = false;
-        }
+        #endif
+
+      }else if(tennisBuffer < 5){   //give 5 frames to recover if tennisball lost due to noise
+        tennisBuffer++;
+      }else
+        tennisMessage.found = false;
+    }
 
-        lcm_.publish("/tennis_ball", &tennisMessage);
-        lcm_.publish("/obstacle", &obstacleMessage);
+    lcm_.publish("/tennis_ball", &tennisMessage);
+    lcm_.publish("/obstacle", &obstacleMessage);
 
-	#ifdef PERCEPTION_DEBUG
-    	imshow("depth", depth_img);
-        imshow("image", src);
-	waitKey(FRAME_WAITKEY);
-	#endif
-        auto end = chrono::high_resolution_clock::now();
+    #ifdef PERCEPTION_DEBUG
+      imshow("depth", depth_img);
+      imshow("image", src);
+      waitKey(FRAME_WAITKEY);
+    #endif
+    auto end = chrono::high_resolution_clock::now();
 
-        auto delta = chrono::duration_cast<chrono::duration<double>>(end - start);
-        frame_time += delta.count();
-	#ifdef PERCEPTION_DEBUG
+    auto delta = chrono::duration_cast<chrono::duration<double>>(end - start);
+    frame_time += delta.count();
+    #ifdef PERCEPTION_DEBUG
         if(j % 100 == 0){
             cout << "framerate: " << 1.0f/(frame_time/j) << endl;
         }
-	#endif
-        j++;
-    }
+    #endif
+    j++;
+    usleep(1000);
+  }
 
-    //cam.deleteZed();
-    return 0;
+  return 0;
 }
diff --git a/onboard/cv/meson_options.txt b/onboard/cv/meson_options.txt
index 9cfb628..abb5c6b 100644
--- a/onboard/cv/meson_options.txt
+++ b/onboard/cv/meson_options.txt
@@ -1,3 +1,3 @@
-option('with_zed', type: 'boolean', value : true)
-option('offline_test', type: 'boolean', value: false)
-option('perception_debug', type: 'boolean', value: false)
+option('with_zed', type: 'boolean', value : false)
+option('offline_test', type: 'boolean', value: true)
+option('perception_debug', type: 'boolean', value: true)
diff --git a/onboard/cv/obstacle_detector.cpp b/onboard/cv/obstacle_detector.cpp
index fba0aa6..da5c01c 100644
--- a/onboard/cv/obstacle_detector.cpp
+++ b/onboard/cv/obstacle_detector.cpp
@@ -6,6 +6,24 @@ using namespace std;
 static int last_center;
 
 
+bool check_divided_window(Mat & rgb_img, int num_splits, Mat & mean_row_vec, int start_col, int end_col){
+  int split_size = (end_col - start_col)/num_splits;
+  for(int i = 0; i < num_splits; i++){  //check each sub window
+    Mat sub_col = mean_row_vec.colRange(start_col, start_col + split_size);
+    float window_sum = sum(sub_col)[0];
+    #ifdef PERCEPTION_DEBUG
+      cout << "Sub[" <<i << "] sum = " << window_sum <<endl;
+    #endif
+    if(window_sum < THRESHOLD_NO_SUBWINDOW){ 
+      #ifdef PERCEPTION_DEBUG
+        rectangle(rgb_img, Point( start_col, SKY_START_ROW), Point( start_col+split_size, GROUND_START_ROW/*RESOLUTION_HEIGHT*/), Scalar(50, 50, 255), 3);
+      #endif
+        return false;
+    }
+    start_col+=split_size;  //update the start col
+  }
+  return true; //all good 
+}
 
 // Goal: if ahead is safe zone, keep going straight
 // try to go straigh as much as possible
@@ -21,13 +39,15 @@ obstacle_return scan_middle(Mat & rgb_img, float center_point_depth,  int rover_
   int center_start_col = (img_shape.width - rover_width )/2;
   Mat sub_col =  mean_row_vec.colRange(center_start_col, center_start_col+rover_width-1 );
   middle_sum = sum( sub_col )[0];
-  
+
   if(middle_sum > THRESHOLD_NO_OBSTACLE_CENTER){
-    #ifdef PERCEPTION_DEBUG
-    rectangle(rgb_img, Point( center_start_col, 0), Point( center_start_col+rover_width-1, RESOLUTION_HEIGHT), Scalar(0, 0, 255), 3);
-    cout<<"No turn: center window sub_col sum is "<<middle_sum<<endl;
-    #endif
-    noTurn.bearing = 0;
+    if(check_divided_window(rgb_img, 4, mean_row_vec, center_start_col, center_start_col+rover_width-1)){
+      #ifdef PERCEPTION_DEBUG
+      rectangle(rgb_img, Point( center_start_col, SKY_START_ROW), Point( center_start_col+rover_width-1, GROUND_START_ROW/*RESOLUTION_HEIGHT*/), Scalar(0, 255, 0), 3);
+      cout<<"No turn: center window sub_col sum is "<<middle_sum<<endl;
+      #endif
+      noTurn.bearing = 0;
+    }
   }
   return noTurn;
 }
@@ -42,7 +62,7 @@ pair<int, float> get_final_col(vector<pair<int, float> > & sorted_sums, float mi
   float max_sum_threshold = sorted_sums[0].second - SIMILARITY_THRESHOLD;
   // go straight if possible
   #ifdef PERCEPTION_DEBUG
-  cout<<"middle col sum is "<<middle_sum<<endl;
+    cout<<"middle col sum is "<<middle_sum<<endl;
   #endif
 
   if (max_sum_threshold < middle_sum) {
@@ -51,8 +71,8 @@ pair<int, float> get_final_col(vector<pair<int, float> > & sorted_sums, float mi
   
   vector<pair<int, float> >::iterator final = lower_bound( sorted_sums.begin(), sorted_sums.end(), make_pair(0, max_sum_threshold), compare_second );
   #ifdef PERCEPTION_DEBUG
-  for (vector<pair<int, float> >::iterator it=sorted_sums.begin(); it!=final; it++) cout<<"("<<it->first<<", "<<it->second<<")";
-  cout<<endl;
+    for (vector<pair<int, float> >::iterator it=sorted_sums.begin(); it!=final; it++) cout<<"("<<it->first<<", "<<it->second<<")";
+    cout<<endl;
   #endif
   
   if (final == sorted_sums.end()) {
@@ -66,8 +86,8 @@ pair<int, float> get_final_col(vector<pair<int, float> > & sorted_sums, float mi
     for (vector<pair<int, float> >::iterator it=sorted_sums.begin(); it!= final; it++ ) {
       int curr_diff = abs(it->first - last_center);
       if ( curr_diff < smallest_diff ) {
-	smallest_diff = curr_diff;
-	smallest_dist_pair = *it;
+        smallest_diff = curr_diff;
+        smallest_dist_pair = *it;
       }
     }
     return smallest_dist_pair;
@@ -84,12 +104,12 @@ obstacle_return refine_rt(obstacle_return rt_val, pair<int, float> candidate, Si
   if (max_sum_sw > THRESHOLD_NO_WAY) {
     #ifdef PERCEPTION_DEBUG
     cout<<"max_sum_sw "<<max_sum_sw<<", col start at "<<final_start_col<<endl;
-    rectangle(rgb_img, Point( final_start_col, 0), Point( final_start_col+rover_width, RESOLUTION_HEIGHT), Scalar(0, 0, 255), 3);
+    rectangle(rgb_img, Point( final_start_col, SKY_START_ROW), Point( final_start_col+rover_width, GROUND_START_ROW/*RESOLUTION_HEIGHT*/), Scalar(255, 0, 0), 3);
     #endif
 
     // compute bearing
     if (size.width /2 > final_start_col  + (rover_width * 2 / 5) &&
-	size.width /2 < final_start_col  + (rover_width* 3 / 5 )) {
+          size.width /2 < final_start_col  + (rover_width* 3 / 5 )) {
       last_center = RESOLUTION_WIDTH / 2;
       rt_val.bearing = 0;
     } else {
@@ -114,7 +134,7 @@ obstacle_return avoid_obstacle_sliding_window(Mat &depth_img_src, Mat &rgb_img,
   patchNaNs(depth_img, 0.0);
   depth_img = max(depth_img, 0.7);
   depth_img = min(depth_img, 20.0);
-  depth_img = depth_img(Rect( 0, 450,  1280, 250));
+  depth_img = depth_img(Rect( 0, SKY_START_ROW,  1280, GROUND_START_ROW - SKY_START_ROW)); //what is this?
   
   blur( depth_img, depth_img, Size( 7, 7 ), Point(-1,-1) );
   Size size = depth_img.size();
@@ -156,11 +176,11 @@ obstacle_return avoid_obstacle_sliding_window(Mat &depth_img_src, Mat &rgb_img,
 
   // try to reduce noise
   // 0 for middle
-  pair<int, float> final_window = get_final_col(sums, middle_sum);
+  pair<int, float> final_window = get_final_col(sums, middle_sum); //may add split window check
   if (final_window.first == -1) {
     #ifdef PERCEPTION_DEBUG
-    cout<<"max_sum_sw "<<final_window.second<<" at center\n";
-    rectangle(rgb_img, Point( size.width / 2 - rover_width/2, 0), Point( size.width/2 + rover_width/2, RESOLUTION_HEIGHT), Scalar(0, 0, 255), 3);
+      cout<<"max_sum_sw "<<final_window.second<<" at center\n";
+      rectangle(rgb_img, Point( size.width / 2 - rover_width/2, SKY_START_ROW), Point( size.width/2 + rover_width/2, GROUND_START_ROW/*RESOLUTION_HEIGHT*/), Scalar(255, 0, 0), 3);
     #endif
 
     last_center = RESOLUTION_WIDTH/2;
diff --git a/onboard/cv/perception.hpp b/onboard/cv/perception.hpp
index f654445..7e111a6 100644
--- a/onboard/cv/perception.hpp
+++ b/onboard/cv/perception.hpp
@@ -1,4 +1,5 @@
 #pragma once
+#define PERCEPTION_DEBUG
 #include <iostream>
 #include <opencv2/opencv.hpp>
 #include "camera.hpp"
@@ -14,17 +15,17 @@
 #include <cstdlib>
 #endif
 
+#define THRESHOLD_NO_WAY  300000 //how will we calibrate if the rover width changes
+#define THRESHOLD_NO_OBSTACLE_CENTER  299000
+#define THRESHOLD_NO_SUBWINDOW 69000
+#define SKY_START_ROW 190
+#define GROUND_START_ROW 670
+#define BALL_DETECTION_MAX_DIST 15  // this number is obtained from experiment. if the distance of the detected ball is greater than this number, false detection, we should ignore
 
-#define THRESHOLD_NO_WAY   85000 //how will we calibrate if the rover width changes
-#define THRESHOLD_NO_OBSTACLE_CENTER  120000
-#define SKY_START_ROW 200
-#define BALL_DETECTION_MAX_DIST 3.50  // this number is obtained from experiment. if the distance of the detected ball is greater than this number, false detection, we should ignore
-
-#define SIMILARITY_THRESHOLD 8000
+#define SIMILARITY_THRESHOLD 1000
 
 #define PI 3.14159265
-#define FRAME_WAITKEY 1 // for cv::imshow
-
+#define FRAME_WAITKEY 0 // for cv::imshow
 
 const int RESOLUTION_WIDTH = 1280;
 const int RESOLUTION_HEIGHT = 720; // 720p
@@ -46,7 +47,7 @@ struct obstacle_return {
 
 // these are for online data collection
 const bool  WRITE_CURR_FRAME_TO_DISK = false;
-const std::string DEFAULT_ONLINE_DATA_FOLDER("/home/mrover/auton_data/");
+const std::string DEFAULT_ONLINE_DATA_FOLDER("/home/jessica/auton_data_comp_sun/");
 
 std::vector<cv::Point2f> findTennisBall(cv::Mat &src, cv::Mat &depth_src);
 obstacle_return avoid_obstacle_sliding_window(cv::Mat &depth_img, cv::Mat &rgb_img, int num_windows, int rover_width );
diff --git a/onboard/cv/tennisball_detector.cpp b/onboard/cv/tennisball_detector.cpp
index e74c3db..19873a4 100644
--- a/onboard/cv/tennisball_detector.cpp
+++ b/onboard/cv/tennisball_detector.cpp
@@ -37,8 +37,8 @@ Mat greenFilter(const Mat& src){
 
     Mat greenOnly;
     // 36 170 80
-    Scalar lowerb = Scalar(36, 170, 80);
-    Scalar upperb = Scalar(43, 226, 196);
+    Scalar lowerb = Scalar(35, 140, 80);//(36, 170, 80);
+    Scalar upperb = Scalar(55, 226, 220);//43, 226, 196);
     inRange(src, lowerb, upperb, greenOnly);
 
     return greenOnly;
